# 操作系统

## 虚拟内存

虚拟内存使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间）。然而，它实质上是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上。

MMU来进行虚拟寻址，页表把虚拟内存映射到物理内存

优点：扩大地址空间，内存保护隔离，

## Linux

内存模型：

内核区

环境变量命令行参数

栈

共享库

堆

.bss 未

.data 以初始化的全局变量

.text 代码段

受保护nullptr



fork() 父进程返回子进程id，子进程返回0

fork后用户区一样，内核区也拷贝过来，除了内核区的pid不一样。读时共享，写时拷贝。

孤儿进程：父进程结束了的子进程，内核将父进程设置为init，会循环wait()它以退出的子进程，无害。

僵尸进程：子进程终止时，父进程尚未回收，又一直不wait，PCB就会才留在内核里。



### 进程通信

pipe, 匿名，内存里，只能有亲缘关系通信。单向，半双工

mkfifo，有名，文件系统里有文件

内存映射：mmap磁盘文件的数据映射到内存，munmap

信号：kill，raise，abort，还有信号集，信号捕获sigaction

共享内存：多个进程共享物理内存的同一区域，shmget shmat shmdt shmctl，用memcpy写数据



线程共享内核区和用户区除了栈和.text的虚拟地址空间

pthread

pthread_mutex

pthread_rwlock

pthread_cond  _wait, _timewait等待， _signal唤醒等待

信号量可以用在线程或进程，sem_   _wait 减一 _post加一 信号量，



客户端：s c sr c

服务端：s b l a rs c







Linux下轻量级高并发服务器，实现对GET请求的响应。

\> 利用epoll I/O多路复用边沿触发模式实现对文件描述符监听，实现模拟Proactor模式，通过共享工作队列实现线程池来处理连接，利用有限状态机实现解析HTTP请求，使用共享内存和分散写将HTTP报文头写回客户端。

收获：个人对于Linux系统编程和网络编程有了一定的理解。

# C++

### new 和 malloc 失败情况

1. 内存不足

2. 在前面的程序中出现了内存的越界访问



### 内存对齐

**有效对齐值**：是 `#pragma pack`指定值 和 结构体中最长数据类型长度 中**较小**的那个。有效对齐值也叫**对齐单位**。

结构体内类型相同的连续元素将在连续的空间内，和数组一样。

(1) 结构体第一个成员的**偏移量（offset）**为0，以后每个成员相对于结构体首地址的 offset 都是**该成员大小与有效对齐值中较小那个**的整数倍，如有需要编译器会在成员之间加上填充字节。

(3) **结构体的总大小**为 有效对齐值 的**整数倍**，如有需要编译器会在最末一个成员之后加上填充字节。

c++11以后引入两个关键字 [alignas](https://zh.cppreference.com/w/cpp/language/alignas)与 [alignof](https://zh.cppreference.com/w/cpp/language/alignof)。其中`alignof`可以计算出类型的对齐方式，`alignas`可以指定结构体的对齐方式。





### 类的大小

64 位指针为 8

空类1

虚函数指针 8，无论几个虚函数都是8，除非是多继承

普通函数不占

静态数据成员之所以不计算在类的对象大小内，是因为类的静态数据成员被该类所有的对象所共享，并不属于具体哪个对象，静态数据成员定义在内存的全局区。



### new、operator new、placement new

new 外层

operator new 申请内存，可以重载

palcement new 构造对象。如果你想在预分配的内存上创建对象，用缺省的new操作符是行不通的。要解决这个问题，你可以用placement new构造。它允许你构造一个新对象到预分配的内存上。

```cpp
int main()
{
    char* buf = new char[sizeof(X)];
    X *px = new(buf) X;
    px->SetNum(10);
    cout<<px->GetNum()<<endl;
    px->~X();
    delete []buf;

    return 0;
}
```



### 打印源文件和当前行号

用宏

```cpp
__FILE__    宏在预编译时会替换成当前的源文件名
__LINE__   宏在预编译时会替换成当前的行号

```



### delete两次

未定义的行为，可能会堆污染。

### 静态成员变量在main之前初始化

### const

**const默认作用于其左边的东西，否则作用于其右边的东西**

### memcopy和memmove

如果目标区域和源区域有重叠的话：
memcpy不能够确保源串所在重叠区域在拷贝之前被覆盖。
memmove能够保证源串在被覆盖之前将重叠区域的字节拷贝到目标区域中，复制后src内容会被更改，当目标区域与源区域没有重叠则和memcpy函数功能相同。

但当源内存和目标内存存在重叠时，memcpy会出现错误，而memmove能正确地实施拷贝，但这也增加了一点点开销。

## STL

**1、容器（containers）**:各种数据结构，如 vector, list, deque, set, map 用来存放数据。从实现的角度来看，STL 容器是一种 class template。

**2、算法（algorithms）**：各种常用的算法如 sort, search, copy, erase…从实现角度来看，STL 算法是一种 function template。

**3、迭代器（iterators）**：扮演容器与算法之间的胶合剂，是所谓的“泛型指针”。从实现角度来看，迭代器是一种将 operator *, operator ->, operator++, operator– 等指针相关操作予以重载的class template。

**4、仿函数（functors）**：行为类似函数，可以作为算法的某种策略。从实现角度来看，仿函数是一种重载了 operator() 的 class 或class template。

**5、适配器（adapters）**：一种用来修饰容器或仿函数或迭代器接口的东西。例如 STL 提供的 queue 和 stack，虽然看似容器，其实只能算是一种容器适配器，因为它们的底部完全借助 deque，所有操作都由底层的 deque 供应。

**6、配置器（allocator）**：负责空间配置与管理，从实现角度来看，配置器是一个实现了动态空间配置、空间管理、空间释放的 class template。



### allocator

为了精密分工，STL allocator 决定将这两个阶段操作区分开来。

c. 对象构造由 ::construct() 负责；对象释放由 ::destroy() 负责。

d. 内存配置由 alloc::allocate() 负责；内存释放由 alloc::deallocate() 负责；



考虑到小型区块可能造成的内存破碎问题，SGI 为此设计了双层级配置器。当配置区块超过 128bytes 时，称为足够大，使用第一级配置器，直接使用 malloc() 和 free()。

当配置区块不大于 128bytes 时，为了降低额外负担，直接使用第二级配置器，采用复杂的 memory pool 处理方式（free_list ）。



### iterator

迭代器其实也是一种模板 `class`

如果不是原生指针，可以用**函数模板参数推导机制 + typedef机制获取类型**

**通过类模板的特化来支持原生指针的版本**



# 计算机网络

## 拥塞控制

慢开始：当cwnd < ssthresh时，让cwnd从1开始指数增加拥塞窗口的值

拥塞避免：当cwnd > ssthresh时, 通过线性增长cwnd的值，降低拥塞的概率

快重传：在丢包发生的情况下，接收端重复发送上一次接受的重复确认，发送方收到了累计3个连续的报文段的重复确认，立即重传之后的报文段

快恢复：收到3个重复确认，不启动慢开始，执行快恢复

## 域名解析

输入地址后，先看浏览器缓存和本地host文件有没有网址映射。

浏览器查找路由器缓存，本地DNS解析器，到这里第递归解析。

然后迭代解析根域名服务器，顶级域名服务器，主域名服务器。

拿到了服务器IP，三次握手建立TCP连接，端口号http是80，https是443还要建立TLS连接

向服务器发送HTTP请求

服务器处理请求，返回响应结果

四次挥手关闭TCP连接

浏览器解析HTML，CSS，JS，媒体资源


# 图形学

## 渲染管线

四个阶段：yjgx

应用：CPU端进行处理，包括碰撞检测、动画物理模拟。CPU将顶点信息送到管线

几何：顶点。顶点着色器、投影变换、裁剪和屏幕映射。

光栅化：之前都是顶点，现在图元组装，组装成点线三角形。图元映射成屏幕的像素

像素处理：计算对象是像素，着色（光照阴影）和混合。屏幕特效如高斯模糊，景深等。



(1) 应用阶段：应用阶段是指在CPU端进行处理的阶段，包括物理碰撞检测、物理模拟、动画计算等任务，对于3D游戏来说，游戏中包含大量的模型，3D模型中保存着模型的顶点坐标，法线，切线，颜色等数据，这些数据一般通过向量进行存储，CPU从模型中获取这些顶点信息数据，并将这些数据传送给GPU作为最开始的输入数据。然后将数据送到渲染管线中。
(2) 几何阶段：几何阶段主要执行顶点.坐标变换、顶点处理、坐标裁剪等操作，计算对象为顶点数据，即模型的顶点数据，在这个阶段，做的最多的操作就是顶点坐标变换，从模型空间变换到世界空间，然后再从世界空间变换至相机空间。这样在相机坐标系下就能方便地进行裁剪，裁剪的作用是判断顶点是否可见。
(3) 光栅化阶段：相比于屏幕上的像素点，顶点数据要少很多，这就有一个问题：无法实现从顶点数据到屏幕像素上的映射。而为了达到这一目的，就出现了顶点插值运算，即将两个顶点之间的空缺部分通过插值的形式进行填充，以达到能实现从顶点数据到像素上的一一映射，最后将渲染的结果显示到屏幕上。
(4) 像素处理阶段：像素处理阶段包括像素颜色计算、像素变换，透明度混合等操作，处理物体渲染顺序及深度测试等。这个阶段要处理的内容比较多，可以在此阶段中利用一些算法实现非常多的屏幕特效，比如高斯模糊，景深等，此阶段是游戏渲染中应用非常广泛的阶段，但因为计算对象是像素点，因此实现相关特效时比较耗费性能。



## 四元数

一个实部三个虚部

p1 = qpq-1

# Unreal

## Event 和 Function 区别

1. Function can return value(s). Event cannot have any output.
2. Event can use Delay node or timelines.
3. Function can use local variables(s).
4. Event can be replicated (as in multiplayer)

## Actor生命周期todo

创建Actor有4种：Play In Editor，LoadMap和AddToWorld，SpawnActor，SpawnActorDeffered

## GamePlay

Game
