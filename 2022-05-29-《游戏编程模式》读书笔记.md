---
title: 2022-05-29-《游戏编程模式》读书笔记
description: 简略记下
#date: 2018-11-22 
#updated: 2020-07-25
categories:
- 读书笔记
tags:
- 读书笔记
---

# 第二篇

## 第 2 章 命令模式

本来是 if xxx: 执行函数

命令模式是把函数写成命令类。



先写一个命令基类，自己写的命令类继承这个基类。

这个类可以接收一些参数（比如角色，这样可以将角色和命令解耦合）（比如要设置的数据，之后会在execute里用到）

这个类有 execute 成员函数、可以有 undo 成员函数。



if xxx: 返回这个类。什么时候 execute 再说。

这样有一个优势就是可以把命令序列化，比如传到远端。



如果要有 undo 函数，就要每次 execute 时把当前状态保存起来。



后面还讲了函数式风格的命令模式。

## 第 3 章 享元模式

享元模式，以共享的方式高效地支持大量的细粒度的对象。通过复用内存中已存在的对象，降低系统创建对象实例的性能消耗。



例子：所有树的模型（mesh、texture）一样，而位置、高度等不同。那么把模型作为一个类，树类里面保存一个指向模型实例的指针就好了。



例子：在World 类里存三种地形的指针。

## 第 4 章 观察者模式

用我自己的话说下吧。

### 发布者

发布者基类有两个方法`addOberserver(Observer* observer)`和`removeObserver(Observer* observer)`，还有一个用来保存观察者的成员变量，可以是单/双链表、集合、数组。还有一个`notify`函数（可以有参数），会遍历所有的观察者，调用它们的`onNotify`函数（可以有参数）

自己写的类想要变成发布者，有两种方法，一种是继承这个发布者基类，还有一种方法是让自己写的类有一个发布者的实例成员。

### 观察者

观察者基类有一个`onNotify`函数（可以有参数）。自己写的类继承观察者基类并实现这个函数

## 第 5 章 原型模式

### 不好的方法

如果用怪物生成器生成3种怪物

怪物基类，三个怪物类继承这个基类

生成器基类，有一个成员函数`virtual Monster* spawnMonster() = 0`, 三个怪物生成器类继承这个基类并重载这个函数。

### 原型模式

基类 Monster，虚函数`virtual Monster* clone()`

三个怪物类继承这个基类，自己实现 clone。

我们只需要**一个**生成器类，它的构造函数接收一个某种怪物的实例指针，保存起来。自己的`Monster* spawnMonster()`函数返回怪物实例的`clone()`函数的调用结果就行了。有一个优点，它也**克隆了对象的状态**

用法就是先创建某种怪物的原型实例，然后再创建存储这个原型实例的生成器类

### 生成器函数

简单来说，就是使用函数指针代替怪物的原型实例。

生成器类的自己的`Monster* spawnMonster()`函数返回函数指针()就行了。

### 模板

用模板类，`spawnMonster()`函数`return new T()`

### 原型数据建模

这个有点像 lua 的元表。

Json 数据实体，有个 key 是 "prototype"，找不到的属性就去这里面找

## 第 6 章 单例模式

介绍：略



有时候我们会有一个 Xx 类，和一个 XxManager 类。

如果我们的 XxManager 类只是操作一个 Xx 对象，我们其实不需要 XxManager 类，让 Xx 自己管理自己就好了



这里还讲了怎样确保单例不提供全局访问。有一个 `static bool instantiated_`，第一次被初始化后会从 `false`编程`true`，然后再初始化就 `assert`

### 为实例提供便捷的访问方式

1. 作为参数传进去
2. 在基类里获取它。例子，`GameObject`基类里有很多成员变量和函数可以用
3. 通过其它全局对象访问，比如`Game`类是个单例，它里面有有`log`、`fileSystem`、`audioPlayer`等
4. 通过服务定位器（16章的设计模式）访问

# 第 7 章 状态模式

